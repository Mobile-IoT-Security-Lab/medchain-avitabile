\section{Implementation Details}

The codebase is organised to keep privacy-critical functionality isolated yet composable. Python orchestrates simulation, proof generation, and integration logic, while Solidity contracts and circom circuits implement the on-chain and zero-knowledge layers respectively. This separation allows rapid prototyping in the simulator without losing sight of deployment targets.

\subsection{System Architecture}
At the core, the \texttt{Models/} package extends the Ateniese redactable blockchain benchmark with explicit smart contract abstractions and role-aware governance policies. The \texttt{medical/MedicalRedactionEngine.py} module coordinates redaction requests, approval tracking, zero-knowledge proof generation, and proof-of-consistency checks produced by \texttt{ZK/ProofOfConsistency.py}. Integration layers under \texttt{adapters/} connect the simulator to external infrastructure: \texttt{adapters/snark.py} wraps the snarkjs CLI, \texttt{adapters/ipfs.py} manages encrypted storage and pinning, and \texttt{adapters/evm.py} (paired with \texttt{medical/backends.py}) exposes a Web3 client for the deployed Solidity contracts in \texttt{contracts/src/}. Circom circuits inside \texttt{circuits/} define the Groth16 redaction verifier, while generated artefacts are consumed both off-chain (Python) and on-chain (Solidity verifier contracts).

\subsection{Data Flows}
Medical records enter the system through the redaction engine, which serialises the payload, stores an encrypted copy in IPFS via the adapter layer, and anchors a commitment plus policy metadata to the blockchain model. Redaction requests trigger policy evaluation, multi-role approvals, and the creation of Groth16 proofs using \texttt{medical/circuit\_mapper.py} to derive deterministic circuit inputs. Successful proofs and consistency checks are attached to the request, after which the chameleon hash trapdoor rewrites the affected block without breaking hash links. When operating against the Solidity deployment, the same flow persists, with the \texttt{MedicalDataManager.sol} contract emitting events that downstream services consume to update off-chain storage. Throughout the pipeline, personal data is encrypted-at-rest and provenance is maintained via hashes and event logs.

\subsection{Technology Stack}
\begin{itemize}
    \item \textbf{Python 3.11}: primary language for the simulator, orchestration, and CLI demos.
    \item \textbf{Circom \& snarkjs}: compile and evaluate Groth16 circuits, producing verifier calldata for Solidity.
    \item \textbf{Solidity + Hardhat}: implement smart contracts (\texttt{MedicalDataManager}, \texttt{RedactionVerifier}) and manage deployments, testing, and coverage.
    \item \textbf{Web3.py}: connect Python workflows to the deployed EVM contracts when \texttt{USE\_REAL\_EVM} is enabled.
    \item \textbf{IPFS (Kubo) + ipfshttpclient}: provide distributed, content-addressed storage with AES-GCM encryption of medical payloads prior to upload.
    \item \textbf{Cryptography \& tooling}: AES-GCM key management, dotenv-based configuration, and pytest-driven verification.
\end{itemize}

\subsection{Zero-Knowledge Proof Generation}
\label{subsec:zk_proofs}

The implementation delivers real Groth16 SNARK proofs integrated into redaction workflows, replacing prior simulations.

\subsubsection{Circuit Input Mapping}

The \texttt{MedicalDataCircuitMapper} class (in \texttt{medical/circuit\_mapper.py}) bridges medical records and cryptographic circuit inputs. Medical data is serialized to canonical JSON format with deterministic field ordering:

\begin{equation}
    \text{canonical}(R) = \text{JSON}(\{
        \text{``patient\_id''}: p_id,
        \text{``diagnosis''}: d,
        \text{``treatment''}: t,
        \text{``physician''}: ph
    \}, \text{sorted\_keys})
\end{equation}

Data is converted to field elements compatible with BN254:

\begin{equation}
    e_i = \left(\text{SHA256}(data)[i \cdot n : (i+1) \cdot n] \bmod 2^{250}\right)
\end{equation}

Circuit inputs separate into public (verified on-chain) and private (prover secret) components:

\textbf{Public inputs:}
\begin{itemize}
    \item Policy hashes (128-bit limbs): $(H_{\text{policy},0}, H_{\text{policy},1})$
    \item Merkle root: $(H_{\text{merkle},0}, H_{\text{merkle},1})$
    \item Original/redacted hashes: $(H_{\text{orig},0}, H_{\text{orig},1}, H_{\text{redact},0}, H_{\text{redact},1})$
    \item Authorization flag: $\text{policyAllowed} \in \{0, 1\}$
\end{itemize}

\textbf{Private inputs:}
\begin{itemize}
    \item Data field elements: $(d_0^{\text{orig}}, d_1^{\text{orig}}, d_2^{\text{orig}}, d_3^{\text{orig}})$ and $(d_0^{\text{redact}}, \ldots)$
    \item Policy field elements: $(d_0^{\text{policy}}, d_1^{\text{policy}})$
    \item Merkle path elements and indices (optional for tree inclusion proofs)
\end{itemize}

\subsubsection{Real Proof Generation}

The \texttt{EnhancedHybridSNARKManager} (in \texttt{medical/my\_snark\_manager.py}) orchestrates real Groth16 generation via snarkjs CLI through the \texttt{adapters/snark.py} wrapper:

\begin{enumerate}
    \item Extract medical record from redaction request
    \item Prepare circuit inputs using \texttt{MedicalDataCircuitMapper}
    \item Validate inputs conform to circuit specification
    \item Call snarkjs to generate witness and proof
    \item Verify proof off-chain before submission
    \item Extract Groth16 components: $(a, b, c)$ and public signals
\end{enumerate}

Each proof is represented as:

\begin{equation}
    \Pi_{\text{redaction}} = (\pi_a, \pi_b, \pi_c, \{\sigma_i\}_{i=0}^{8})
\end{equation}

where $\pi_a, \pi_b, \pi_c$ are BN254 elliptic curve points and $\{\sigma_i\}$ are public signals including:
\begin{itemize}
    \item Commitment to redacted data
    \item Nullifier for replay prevention
    \item Merkle root claim
    \item Policy and authorization flags
\end{itemize}

\subsubsection{Consistency Proof Integration}

The \texttt{ConsistencyProofGenerator} (in \texttt{ZK/ProofOfConsistency.py}) verifies that redaction operations maintain blockchain integrity across five check types: block integrity, hash chain consistency, Merkle tree validity, smart contract state transitions, and transaction ordering.

When a consistency proof is provided, it integrates into circuit public inputs via \texttt{prepare\_circuit\_inputs\_with\_consistency()}:

\begin{equation}
    \text{pubInputs}_{\text{consistency}} = \text{pubInputs}_{\text{base}} \cup \{
        H_{\text{pre},0}, H_{\text{pre},1},
        H_{\text{post},0}, H_{\text{post},1},
        \text{consistencyValid}
    \}
\end{equation}

Pre and post-state hashes are computed as:

\begin{equation}
    H_{\text{state}} = \text{SHA256}(\text{canonical}(\mathcal{S}))
\end{equation}

The circuit then verifies the redaction is cryptographically sound and consistency checks pass before generating a valid proof.

\subsubsection{Implementation Status}

All Phase 1 implementation files are marked with comment \texttt{\#\#\# Bookmark1 for next meeting}:
\begin{itemize}
    \item \texttt{medical/circuit\_mapper.py}, \texttt{medical/my\_snark\_manager.py}, \texttt{medical/MedicalRedactionEngine.py}
    \item \texttt{ZK/SNARKs.py}, \texttt{ZK/ProofOfConsistency.py}, \texttt{adapters/snark.py}
    \item \texttt{tests/test\_circuit\_mapper.py}, \texttt{tests/test\_snark\_system.py}, \texttt{tests/test\_consistency\_system.py}, \texttt{tests/test\_consistency\_circuit\_integration.py}
\end{itemize}

Test coverage includes 20+ unit tests for circuit mapping, 5+ SNARK system tests, 8+ consistency proof tests, and 5+ integration tests. All tests pass without blocking issues.

\subsection{On-Chain Verification}
\label{subsec:onchain_verification}

Phase 2 extends Phase 1 with on-chain verification via smart contracts, enabling trustless, cryptographic validation of redaction operations on the blockchain.

\subsubsection{Nullifier Registry}

The \texttt{NullifierRegistry} contract maintains a mapping of used nullifiers to prevent replay attacks---the re-submission of an identical proof for unintended duplication:

\begin{equation}
    \text{usedNullifiers}: \mathbb{B}_{32} \to \{0, 1\}
\end{equation}

Each SNARK proof produces a unique nullifier via:

\begin{equation}
    n = \text{hash}(\text{public\_signals} \| \text{timestamp} \| \text{prover\_address})
\end{equation}

When a redaction request is processed, the contract:
\begin{enumerate}
    \item Extracts nullifier $n$ from SNARK public signals
    \item Queries registry: $\text{isNullifierUsed}(n)$
    \item Reverts if true (already submitted)
    \item Registers nullifier on success for audit trail
\end{enumerate}

\subsubsection{Groth16 Verifier Integration}

The \texttt{RedactionVerifier\_groth16} contract is auto-generated from snarkjs and implements:

\begin{equation}
    \text{verifyProof}(\pi_a, \pi_b, \pi_c, \{\sigma_i\}) \to \{0, 1\}
\end{equation}

The \texttt{MedicalDataManager} contract integrates this verifier via:

\begin{verbatim}
function requestDataRedactionWithProof(
    string memory patientId,
    string memory redactionType,
    string memory reason,
    uint[2] memory a,
    uint[2][2] memory b,
    uint[2] memory c,
    uint[9] memory publicSignals
) public onlyAuthorized returns (string memory requestId)
\end{verbatim}

This function:
\begin{enumerate}
    \item Calls verifier: $\text{valid} = \text{verifyProof}(a, b, c, \text{publicSignals})$
    \item Extracts nullifier from signals
    \item Checks nullifier registry for replay
    \item Validates consistency proofs (if included)
    \item Creates redaction request
    \item Registers nullifier and emits audit event
\end{enumerate}

Gas cost breakdown: Groth16 verification ($\sim 250k$ gas) + nullifier operations ($\sim 20k$ gas) + state updates ($\sim 50k$ gas) = $\sim 320k$ gas total (approximately \$20 at 100 gwei).

\subsubsection{Python Backend}

The \texttt{EVMBackend} class (in \texttt{medical/backends.py}) extends redaction workflows with on-chain verification:

\begin{verbatim}
def request_data_redaction_with_proof(
    patient_id: str,
    redaction_type: str,
    reason: str,
    medical_record_dict: Dict[str, Any]
) -> Optional[str]
\end{verbatim}

This method:
\begin{enumerate}
    \item Prepares circuit inputs via \texttt{MedicalDataCircuitMapper}
    \item Generates SNARK proof via \texttt{SnarkClient}
    \item Extracts proof components: $(a, b, c)$, public signals
    \item Calls \texttt{MedicalDataManager.requestDataRedactionWithProof()} on-chain
    \item Returns request ID or None on failure
\end{enumerate}

\subsubsection{Circuit Extensions}

The redaction circuit is extended with consistency proof inputs, adding to public inputs:

\begin{equation}
    \{\text{preStateHash0}, \text{preStateHash1}, \text{postStateHash0}, \text{postStateHash1}, \text{consistencyCheckPassed}\}
\end{equation}

The circuit verifies:
\begin{enumerate}
    \item Original data hash matches circuit input
    \item Redacted data hash is correct for operation type
    \item Policy hash is authorized
    \item If consistency enabled: pre/post-state hashes match provided proof
\end{enumerate}

\subsubsection{Phase 2 Implementation Complete}

Phase 2 on-chain verification has been fully implemented and integrated. All components are production-ready with no simulation fallbacks.

\textbf{New Smart Contracts:}
\begin{itemize}
    \item \texttt{NullifierRegistry.sol}: Tracks used nullifiers with timestamps and submitter addresses. Supports batch operations for gas efficiency. Features pause/unpause for emergency control.
    \item Enhanced \texttt{MedicalDataManager.sol}: Now stores full proof metadata including zkProofHash, consistencyProofHash, nullifier, preStateHash, and postStateHash. New function \texttt{requestDataRedactionWithFullProofs()} performs complete verification: nullifier check, SNARK verification, consistency validation, and audit event emission.
\end{itemize}

\textbf{Backend Enhancements:}
\begin{itemize}
    \item \texttt{EVMBackend.request\_data\_redaction\_with\_full\_proofs()}: Submits both SNARK and consistency proofs on-chain. Generates nullifiers from proof data, validates via registry before submission, computes state hashes from consistency proofs, and handles Groth16 calldata formatting for Solidity.
    \item \texttt{MedicalRedactionEngine}: Wires consistency proofs into SNARK generation, parses proof artifacts for on-chain submission via \texttt{\_parse\_groth16\_for\_solidity()}, and integrates Phase 2 verification in \texttt{request\_data\_redaction()}.
\end{itemize}

\textbf{Verification Flow:}
\begin{enumerate}
    \item Off-chain: Generate real Groth16 proof for redaction operation
    \item Off-chain: Generate consistency proof with pre/post-state hashes
    \item Off-chain: Compute unique nullifier from proof data
    \item On-chain: Contract checks nullifier not used (replay prevention)
    \item On-chain: Contract verifies SNARK proof cryptographically via Groth16 verifier
    \item On-chain: Contract stores consistency proof hash commitment
    \item On-chain: Contract records nullifier to prevent future replays
    \item On-chain: Contract emits \texttt{ProofVerifiedOnChain}, \texttt{NullifierRecorded}, \texttt{ConsistencyProofStored} events
    \item Off-chain: Approval and execution proceed with on-chain state updates
\end{enumerate}

\textbf{Testing Coverage:}

Integration test suite includes:
\begin{itemize}
    \item \texttt{test\_phase2\_onchain\_verification.py}: End-to-end Phase 2 workflow, nullifier registry deployment, replay attack prevention, batch nullifier operations, consistency proof storage, event emissions
    \item \texttt{test\_nullifier\_registry.py}: Nullifier validity checking, recording and duplicate rejection, batch operations, info retrieval, pause/unpause functionality
\end{itemize}

All tests pass without blocking issues. Gas costs: SNARK verification $\sim$250k gas, nullifier operations $\sim$20k gas, full request submission $\sim$350k gas total.

\textbf{Deployment:}

Automated deployment via \texttt{contracts/scripts/deploy\_phase2.js}:
\begin{enumerate}
    \item Deploy \texttt{NullifierRegistry}
    \item Deploy \texttt{RedactionVerifier\_groth16} (auto-generated from snarkjs)
    \item Deploy \texttt{MedicalDataManager} with verifier and registry addresses
    \item Verify configuration (check registry reference, verifier type, proof requirements)
    \item Save deployment addresses to \texttt{deployed\_addresses.json}
    \item Generate environment configuration template
\end{enumerate}

\textbf{Implementation Status:}

All Phase 2 files marked with comment \texttt{\#\#\# Bookmark2 for next meeting}:
\begin{itemize}
    \item Smart Contracts: \texttt{NullifierRegistry.sol} (NEW), \texttt{MedicalDataManager.sol} (UPDATED)
    \item Python Backend: \texttt{backends.py}, \texttt{MedicalRedactionEngine.py}, \texttt{adapters/evm.py}
    \item ZK Components: \texttt{ZK/SNARKs.py}, \texttt{ZK/ProofOfConsistency.py}, \texttt{medical/circuit\_mapper.py}
    \item Tests: \texttt{test\_phase2\_onchain\_verification.py} (NEW), \texttt{test\_nullifier\_registry.py} (NEW)
    \item Deployment: \texttt{deploy\_phase2.js} (NEW)
\end{itemize}

\textbf{Key Achievements:}
\begin{itemize}
    \item Zero simulation code in production path
    \item All proofs are real and cryptographically verifiable
    \item Complete replay attack prevention via nullifiers
    \item On-chain consistency proof commitments
    \item Full audit trail with blockchain events
    \item Production-ready deployment scripts
    \item Comprehensive test coverage
\end{itemize}

This completes the Avitabile additions to the Ateniese redactable blockchain: smart contract governance with zero-knowledge proofs and on-chain verification, transitioning from theoretical design to deployed, working implementation.


