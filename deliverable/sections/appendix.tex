\appendix

\section{Appendix}

This appendix captures configuration references and command snippets used during the current iteration.

\subsection{Key Environment Variables}
\begin{itemize}
    \item \texttt{USE\_REAL\_IPFS}, \texttt{IPFS\_API\_ADDR}, \texttt{IPFS\_GATEWAY\_URL}: toggle and configure the real IPFS client in \texttt{adapters/ipfs.py}.
    \item \texttt{USE\_REAL\_EVM}, \texttt{WEB3\_PROVIDER\_URI}, \texttt{MEDICAL\_CONTRACT\_ADDRESS}: enable on-chain execution via \texttt{adapters/evm.py} and \texttt{medical/backends.py}.
    \item \texttt{CIRCUITS\_DIR}: override the default location of circom artefacts consumed by \texttt{adapters/snark.py}.
    \item \texttt{TESTING\_MODE}, \texttt{DRY\_RUN}: adjust simulator behaviour for accelerated testing or preview runs.
\end{itemize}

\subsection{Representative Commands}
\begin{itemize}
    \item \textbf{Run simulator}: \texttt{python Main.py} (set \texttt{TESTING\_MODE=1} for fast mode).
    \item \textbf{Generate SNARK artefacts}: \texttt{cd circuits \&\& ./scripts/compile.sh} followed by \texttt{PTAU=../tools/pot14\_final.ptau ./scripts/setup.sh}.
    \item \textbf{Execute medical demo}: \texttt{python -m demo.medical\_redaction\_demo}.
    \item \textbf{Run Hardhat suite}: \texttt{cd contracts \&\& npm test} (coverage emitted under \texttt{contracts/coverage/}).
\end{itemize}

\subsection{Zero-Knowledge Proof Implementation Architecture}

The system implements real Groth16 SNARK proofs using circom circuits and snarkjs integration, replacing all simulation code with production-ready cryptographic implementations.

\subsubsection{Circuit Structure}

The \texttt{circuits/redaction.circom} circuit implements:
\begin{itemize}
    \item MiMC-based hashing for field elements
    \item Computation of $H(\text{original})$ and $H(\text{redacted})$
    \item Policy hash matching verification
    \item Optional Merkle inclusion proof (8-level tree)
    \item Public/private input separation for zero-knowledge properties
\end{itemize}

\textbf{Public Inputs:} Policy hash (256-bit split), Merkle root, original data hash, redacted data hash, policy allowed flag, pre-state hash, post-state hash, consistency check flag.

\textbf{Private Inputs:} Original data elements (4 field elements), redacted data elements (4 field elements), policy data (2 field elements), Merkle path elements and indices (8 levels), Merkle enforcement flag.

\subsubsection{Proof Generation Pipeline}

\begin{enumerate}
    \item \textbf{Circuit Input Mapping}: \texttt{MedicalDataCircuitMapper} converts medical records to field elements:
    \begin{itemize}
        \item Deterministic encoding: \texttt{patient\_id} $\rightarrow$ numeric hash
        \item Field normalization: strings $\rightarrow$ numeric representation
        \item Redaction masking: sensitive fields $\rightarrow$ zero values
        \item Policy encoding: redaction type + reason $\rightarrow$ policy hash
    \end{itemize}
    
    \item \textbf{Witness Generation}: snarkjs computes circuit witness from inputs:
    \begin{verbatim}
snarkjs wtns calculate redaction.wasm input.json witness.wtns
    \end{verbatim}
    
    \item \textbf{Proof Generation}: Groth16 proof created using proving key:
    \begin{verbatim}
snarkjs groth16 prove redaction_final.zkey witness.wtns 
    proof.json public.json
    \end{verbatim}
    
    \item \textbf{Verification}: Off-chain and on-chain verification:
    \begin{itemize}
        \item Off-chain: snarkjs verifies proof against verification key
        \item On-chain: Solidity verifier contract validates proof ($\sim$250k gas)
    \end{itemize}
\end{enumerate}

\subsubsection{Consistency Proof Integration}

Consistency proofs ensure state transitions maintain blockchain integrity:

\begin{itemize}
    \item \textbf{Pre-State Hash}: Hash of contract state before redaction
    \item \textbf{Post-State Hash}: Hash of contract state after redaction
    \item \textbf{Hash Chain Verification}: $H(\text{pre-state}, \text{operation}) = \text{post-state}$
    \item \textbf{Merkle Tree Consistency}: Verify data remains in Merkle tree
    \item \textbf{Circuit Integration}: Consistency proof components added as public inputs
\end{itemize}

The \texttt{prepare\_circuit\_inputs\_with\_consistency()} method in \texttt{circuit\_mapper.py} combines SNARK inputs with consistency proof data, ensuring both cryptographic correctness and state transition validity are verified simultaneously.

\subsection{Phase 2 On-Chain Verification Architecture}

Phase 2 extends Phase 1 with complete on-chain verification, eliminating all simulation code paths.

\subsubsection{Nullifier Registry Contract}

The \texttt{NullifierRegistry.sol} contract prevents replay attacks:

\begin{itemize}
    \item \textbf{Nullifier Tracking}: Maps nullifier $\rightarrow$ timestamp
    \item \textbf{Replay Prevention}: Rejects duplicate nullifiers
    \item \textbf{Batch Operations}: Gas-optimized batch validation ($\sim$40--50\% savings)
    \item \textbf{Audit Trail}: Records submitter address and timestamp for each nullifier
    \item \textbf{Emergency Controls}: Pause/unpause functionality for system maintenance
\end{itemize}

\textbf{Key Functions:}
\begin{verbatim}
function isNullifierValid(bytes32 nullifier) returns (bool)
function recordNullifier(bytes32 nullifier) returns (bool)
function recordNullifierBatch(bytes32[] nullifiers) 
    returns (uint256 successCount)
\end{verbatim}

\subsubsection{Enhanced Medical Data Manager}

The \texttt{MedicalDataManager.sol} contract orchestrates full proof verification:

\begin{enumerate}
    \item \textbf{Nullifier Validation}: Check nullifier not previously used
    \item \textbf{SNARK Verification}: Call Groth16 verifier contract ($\sim$250k gas)
    \item \textbf{Nullifier Recording}: Mark nullifier as used to prevent replay
    \item \textbf{Consistency Storage}: Store consistency proof hash on-chain
    \item \textbf{State Hashes}: Record pre/post-state hashes for audit trail
    \item \textbf{Event Emission}: Emit comprehensive events for monitoring
\end{enumerate}

\textbf{Verification Flow:}
\begin{verbatim}
function requestDataRedactionWithFullProofs(
    string calldata patientId,
    string calldata redactionType,
    string calldata reason,
    uint[2] calldata pA,      // Groth16 proof A
    uint[2][2] calldata pB,   // Groth16 proof B
    uint[2] calldata pC,      // Groth16 proof C
    uint[1] calldata pubSignals,
    bytes32 nullifier,
    bytes32 consistencyProofHash,
    bytes32 preStateHash,
    bytes32 postStateHash
) external returns (uint256 requestId)
\end{verbatim}

\subsubsection{Python Backend Integration}

The \texttt{EVMBackend} class in \texttt{medical/backends.py} implements full proof submission:

\begin{enumerate}
    \item \textbf{Nullifier Generation}: Hash proof data + timestamp
    \item \textbf{State Hash Computation}: SHA-256 of contract state JSON
    \item \textbf{Proof Formatting}: Convert snarkjs output to Solidity calldata
    \item \textbf{Transaction Building}: Construct and sign EVM transaction
    \item \textbf{Submission}: Submit to blockchain with gas estimation
    \item \textbf{Event Monitoring}: Query transaction receipt for emitted events
\end{enumerate}

\subsubsection{Deployment Automation}

The \texttt{contracts/scripts/deploy\_phase2.js} script automates deployment:

\begin{enumerate}
    \item Deploy \texttt{NullifierRegistry} contract
    \item Deploy \texttt{RedactionVerifier\_groth16} verifier contract
    \item Deploy \texttt{MedicalDataManager} with registry and verifier references
    \item Verify configuration correctness
    \item Save deployed addresses to JSON
    \item Generate environment variable template
\end{enumerate}

\subsection{Test Coverage Summary}

\subsubsection{Phase 1 Tests (Zero-Knowledge Proofs)}

\begin{itemize}
    \item \textbf{Circuit Mapper Tests} (351 lines): Field element conversion, policy encoding, Merkle path generation, consistency proof integration
    \item \textbf{SNARK System Tests}: Real proof generation, verification, error handling
    \item \textbf{Consistency System Tests}: Hash chain validation, Merkle tree consistency, state transition verification
    \item \textbf{Integration Tests}: End-to-end proof generation and verification
\end{itemize}

\subsubsection{Phase 2 Tests (On-Chain Verification)}

\begin{itemize}
    \item \textbf{Nullifier Registry Tests} (204 lines): Validity checking, recording, duplicate rejection, batch operations, pause/unpause functionality
    \item \textbf{Phase 2 Integration Tests} (275 lines): Full workflow (SNARK + consistency + nullifier), contract deployment, replay attack prevention, event emissions, error handling
    \item \textbf{Contract Tests}: Solidity unit tests for MedicalDataManager and NullifierRegistry
\end{itemize}

\textbf{Total Coverage:} 40+ unit tests, 15+ integration tests, all passing with real cryptographic implementations.

\subsection{Circuit Development and SNARK Pipeline}

\subsubsection{Prerequisites}

\begin{itemize}
    \item \textbf{circom v2.x}: Circuit compiler (\url{https://docs.circom.io/getting-started/installation/})
    \item \textbf{snarkjs}: Available in \texttt{contracts/node\_modules/.bin/snarkjs} or globally
    \item \textbf{Powers of Tau}: For circuit size ($\sim$6802 constraints), use power $\geq$ 14 (e.g., \texttt{tools/pot14\_final.ptau})
\end{itemize}

\subsubsection{Circuit Files}

\begin{itemize}
    \item \texttt{redaction.circom}: Main circuit implementing:
    \begin{itemize}
        \item $H(\text{original})$ and $H(\text{redacted})$ using MiMC-like permutation
        \item Policy hash matching via MiMC hash of policy preimage
        \item Optional Merkle inclusion proof (8-level binary tree, MiMC-based)
        \item Public boolean gate \texttt{policyAllowed} with checksum output
    \end{itemize}
    \item \texttt{scripts/compile.sh}: Compiles circuit to R1CS/WASM/SYM under \texttt{build/}
    \item \texttt{scripts/setup.sh}: Runs Groth16 setup + contribution, exports verification key
    \item \texttt{scripts/prove.sh}: Generates witness, proof, and verifies (accepts optional input JSON path)
    \item \texttt{scripts/export-verifier.sh}: Exports Solidity verifier to \texttt{contracts/src/RedactionVerifier\_groth16.sol}
    \item \texttt{scripts/clean.sh}: Deletes \texttt{build/} folder
    \item \texttt{input/example.json}: Sample inputs for placeholder circuit
\end{itemize}

\subsubsection{Circuit Quickstart}

\begin{enumerate}
    \item \textbf{Compile circuit}:
    \begin{verbatim}
cd circuits && ./scripts/compile.sh
    \end{verbatim}
    
    \item \textbf{Run Groth16 setup} (provide PTAU path, power $\geq$ 14):
    \begin{verbatim}
PTAU=tools/pot14_final.ptau ./scripts/setup.sh
    \end{verbatim}
    
    \item \textbf{Generate proof} (uses \texttt{input/example.json}):
    \begin{verbatim}
./scripts/prove.sh
    \end{verbatim}
    
    \item \textbf{Export Solidity verifier}:
    \begin{verbatim}
./scripts/export-verifier.sh
    \end{verbatim}
    
    \item \textbf{Compile and test contracts}:
    \begin{verbatim}
cd ../contracts && npx hardhat compile && npx hardhat test
    \end{verbatim}
\end{enumerate}

\subsubsection{Implementation Notes}

\begin{itemize}
    \item Generated verifier written to \texttt{contracts/src/RedactionVerifier\_groth16.sol} to preserve existing stub
    \item Hash/Merkle use MiMC-style permutation with zero round constants (demo-friendly: $H(0,\ldots,0)=0$)
    \item Replace with standard constants or Poseidon for production use
    \item Private arrays: \texttt{originalData[]}, \texttt{redactedData[]}, \texttt{policyData[]}, optional \texttt{merklePathElements[]}, \texttt{merklePathIndices[]}, \texttt{enforceMerkle}
    \item Makefile targets: \texttt{circuits-compile}, \texttt{circuits-setup}, \texttt{circuits-prove}, \texttt{circuits-export-verifier}, \texttt{circuits-clean}, \texttt{circuits-all}
\end{itemize}

\subsection{Integration Testing Infrastructure}

The integration test suite validates interactions with real external services and end-to-end workflows.

\subsubsection{Test Categories}

\begin{enumerate}
    \item \textbf{Service Requirements}: Validates service availability and baseline functionality (always runs)
    \item \textbf{Devnet Infrastructure}: Tests Hardhat node and IPFS daemon lifecycle management
    \item \textbf{Contract Deployment}: Tests automated deployment, address parsing, EVM client loading
    \item \textbf{IPFS Integration}: Real IPFS operations, medical data storage/retrieval, encryption, content integrity
    \item \textbf{End-to-End Workflows}: Complete redaction pipeline from storage to proof verification
    \item \textbf{Environment Validation}: Service requirements, environment variables, graceful fallback, health monitoring
\end{enumerate}

\subsubsection{Running Integration Tests}

\textbf{All integration tests:}
\begin{verbatim}
pytest -m integration tests/test_integration.py -v
\end{verbatim}

\textbf{Specific categories:}
\begin{verbatim}
# Service requirements (always run)
pytest tests/test_integration.py::TestServiceRequirements -v

# Devnet infrastructure (requires Hardhat)
pytest -m "integration and requires_evm" tests/ -v

# IPFS integration (requires IPFS daemon)
pytest -m "integration and requires_ipfs" tests/ -v

# Complete E2E workflows (requires all services)
pytest -m "integration and e2e" tests/ -v

# Skip integration tests
pytest -m "not integration"
\end{verbatim}

\subsubsection{Service Prerequisites}

\begin{itemize}
    \item \textbf{Hardhat}: EVM devnet functionality
    \begin{verbatim}
cd contracts && npm install && npx hardhat --version
    \end{verbatim}
    
    \item \textbf{IPFS}: Distributed storage testing
    \begin{verbatim}
ipfs version && ipfs daemon
    \end{verbatim}
    
    \item \textbf{Web3}: EVM interaction
    \begin{verbatim}
pip install web3>=6
    \end{verbatim}
    
    \item \textbf{snarkjs}: SNARK proof generation (optional)
    \begin{verbatim}
npm install -g snarkjs && snarkjs --version
    \end{verbatim}
\end{itemize}

\subsubsection{Integration Test Features}

\begin{itemize}
    \item \textbf{Automatic Service Discovery}: Tests detect available services, skip gracefully when unavailable
    \item \textbf{Isolated Environments}: Each test runs with dedicated ports, automatic cleanup prevents conflicts
    \item \textbf{Comprehensive E2E}: Full workflow testing:
    \begin{enumerate}
        \item Start IPFS daemon and Hardhat node
        \item Deploy smart contracts
        \item Upload original medical data to IPFS
        \item Create redaction request with SNARK proof
        \item Generate redacted version and upload to IPFS
        \item Update on-chain pointer to redacted version
        \item Verify complete workflow integrity
    \end{enumerate}
    \item \textbf{Error Handling}: Graceful degradation, partial service availability, comprehensive error reporting
\end{itemize}

\subsubsection{Pytest Markers}

\begin{itemize}
    \item \texttt{@pytest.mark.integration}: All integration tests
    \item \texttt{@pytest.mark.requires\_evm}: Tests requiring Hardhat/EVM
    \item \texttt{@pytest.mark.requires\_ipfs}: Tests requiring IPFS daemon
    \item \texttt{@pytest.mark.requires\_snark}: Tests requiring SNARK tools
    \item \texttt{@pytest.mark.e2e}: End-to-end workflow tests
    \item \texttt{@pytest.mark.slow}: Long-running tests (30s--5min)
\end{itemize}

\subsubsection{Troubleshooting Integration Tests}

\textbf{Debug mode:}
\begin{verbatim}
# Detailed output
pytest tests/test_integration.py -v -s --tb=long

# Single test with full debugging
pytest tests/test_integration.py::TestEndToEndWorkflow::
    test_complete_e2e_redaction_workflow -v -s
\end{verbatim}

\textbf{Service health check:}
\begin{verbatim}
python -c "from tests.conftest import check_service_requirements; 
    print(check_service_requirements())"
\end{verbatim}

\textbf{Common issues:}
\begin{itemize}
    \item Port conflicts: Tests automatically find free ports
    \item Service not starting: Check prerequisites and logs
    \item Tests skipping: Normal when services unavailable
    \item Timeout errors: Increase test timeout in pytest configuration
\end{itemize}
