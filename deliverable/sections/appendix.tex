\appendix

\section{Appendix}

\subsection{Implementation Status and Manual Steps}

\textbf{Current State (October 30, 2025):} The codebase is structurally complete with full infrastructure for 16-signal proof verification. However, circuit compilation artifacts require regeneration to activate end-to-end functionality.

\subsubsection{Completed Infrastructure}

All Python and circuit source code is complete:
\begin{itemize}
    \item Circuit (\texttt{circuits/redaction.circom}): 16 public signals defined and declared in \texttt{component main \{public [...]\}}
    \item Circuit Mapper (\texttt{medical/circuit\_mapper.py}): Generates all 16 signals with nullifier and consistency data
    \item SNARK Manager (\texttt{medical/my\_snark\_manager.py}): Extracts nullifier from proof outputs (indices 8--9)
    \item Backend (\texttt{medical/backends.py}): Full \texttt{request\_data\_redaction\_with\_full\_proofs()} implementation
    \item Smart Contracts: \texttt{NullifierRegistry.sol} and infrastructure for proof verification
\end{itemize}

\subsubsection{Circuit Public Signal Mapping}

Table~\ref{tab:public_signals} documents the 16 public signals:

\begin{table}[h]
\centering
\small
\begin{tabular}{clp{5.5cm}}
\toprule
\textbf{Index} & \textbf{Signal} & \textbf{Description} \\
\midrule
0--1 & \texttt{policyHash0/1} & Policy hash (2$\times$128 bits) \\
2--3 & \texttt{merkleRoot0/1} & Merkle root for inclusion \\
4--5 & \texttt{originalHash0/1} & Pre-redaction data hash \\
6--7 & \texttt{redactedHash0/1} & Post-redaction data hash \\
8--9 & \texttt{nullifier0/1} & Replay-prevention nullifier \\
10--11 & \texttt{preStateHash0/1} & Pre-redaction state \\
12--13 & \texttt{postStateHash0/1} & Post-redaction state \\
14 & \texttt{consistencyCheckPassed} & Proof validity flag \\
15 & \texttt{policyAllowed} & Authorization flag \\
\bottomrule
\end{tabular}
\caption{Circuit public signal indices. Signals 8--14 added for Phase 2.}
\label{tab:public_signals}
\end{table}

\subsubsection{Required Manual Steps}

To activate full on-chain verification:

\begin{enumerate}
    \item \textbf{Install circom v2.x} (requires Rust toolchain):
    \begin{verbatim}
curl --proto '=https' --tlsv1.2 \
  https://sh.rustup.rs -sSf | sh
git clone https://github.com/iden3/circom.git
cd circom && cargo build --release
cargo install --path circom
    \end{verbatim}
    
    \item \textbf{Recompile circuits} (generates 16-signal artifacts):
    \begin{verbatim}
make circuits-compile
make circuits-setup PTAU=tools/pot12_0000.ptau
make circuits-export-verifier
    \end{verbatim}
    Verification: \texttt{circuits/build/public.json} should contain 16 elements.
    
    \item \textbf{Update Solidity contracts} to accept 16 signals:
    \begin{verbatim}
// In MedicalDataManager.sol
function requestDataRedactionWithFullProofs(
    ...,
    uint[16] memory pubSignals,  // was uint[1]
    ...
) {
    // Extract nullifier from signals
    bytes32 nullifier = bytes32(
        (uint256(pubSignals[8]) | 
         (uint256(pubSignals[9]) << 128))
    );
    require(nullifier == _nullifier, "Mismatch");
    ...
}
    \end{verbatim}
    
    \item \textbf{Validate end-to-end}:
    \begin{verbatim}
pytest tests/test_consistency_circuit_integration.py
cd contracts && npx hardhat test
    \end{verbatim}
\end{enumerate}

\textbf{Why Manual?} Circuit compilation is time-intensive (5--15 min) and requires circom installation. Build artifacts in \texttt{circuits/build/} currently contain 1 signal from earlier configuration. After recompilation, nullifier extraction, consistency proof verification, and replay attack prevention activate as described in this deliverable.

\subsubsection{Detailed Recompilation Procedure}

The following procedure provides step-by-step instructions for activating the full 16-signal verification system:

\paragraph{Step 1: Environment Setup}

Install required tooling:

\begin{verbatim}
# Install Rust toolchain (required for circom)
curl --proto '=https' --tlsv1.2 \
  https://sh.rustup.rs -sSf | sh
source $HOME/.cargo/env

# Clone and build circom v2.x
git clone https://github.com/iden3/circom.git
cd circom
cargo build --release
cargo install --path circom

# Verify installation
circom --version  # Should show 2.x.x
\end{verbatim}

Install snarkjs (if not already present):

\begin{verbatim}
npm install -g snarkjs
snarkjs --version  # Should show 0.7.x or higher
\end{verbatim}

\paragraph{Step 2: Circuit Compilation}

Navigate to project root and compile circuit:

\begin{verbatim}
cd /path/to/medchain-avitabile

# Compile circuit to R1CS and WASM
make circuits-compile

# Expected output:
#   circuits/build/redaction.r1cs
#   circuits/build/redaction_js/redaction.wasm
#   circuits/build/redaction.sym
\end{verbatim}

Verify compilation succeeded:

\begin{verbatim}
# Check witness generator exists
ls -lh circuits/build/redaction_js/redaction.wasm

# Inspect R1CS info
snarkjs r1cs info circuits/build/redaction.r1cs
# Should show: "# of Public Inputs: 16"
\end{verbatim}

\paragraph{Step 3: Trusted Setup}

Generate proving and verification keys using existing PTAU:

\begin{verbatim}
# Run Groth16 setup (uses pot12_0000.ptau)
make circuits-setup PTAU=tools/pot12_0000.ptau

# Expected output:
#   circuits/build/redaction_0000.zkey (initial)
#   circuits/build/redaction_final.zkey (after contribution)
#   circuits/build/verification_key.json
\end{verbatim}

Verify keys generated correctly:

\begin{verbatim}
# Check key sizes
ls -lh circuits/build/*.zkey
# redaction_final.zkey should be ~4-8 MB

# Export verification key in JSON
snarkjs zkey export verificationkey \
  circuits/build/redaction_final.zkey \
  circuits/build/verification_key.json

# Verify public signal count
jq '.nPublic' circuits/build/verification_key.json
# Should output: 16
\end{verbatim}

\paragraph{Step 4: Verify Public Signals}

Confirm \texttt{public.json} now exports 16 signals:

\begin{verbatim}
cat circuits/build/public.json
# Expected output:
# [
#   "policyHash0", "policyHash1",
#   "merkleRoot0", "merkleRoot1",
#   "originalHash0", "originalHash1",
#   "redactedHash0", "redactedHash1",
#   "nullifier0", "nullifier1",
#   "preStateHash0", "preStateHash1",
#   "postStateHash0", "postStateHash1",
#   "consistencyCheckPassed",
#   "policyAllowed"
# ]
\end{verbatim}

If \texttt{public.json} still shows \texttt{["1"]}, the circuit compilation did not complete successfully. Re-check Step 2.

After exporting the Solidity verifier I need to update \texttt{MedicalDataManager.sol} so it accepts all 16 public inputs, rebuild the Python backend to consume the limb values, redeploy the contracts, and rerun both the Hardhat tests and the Python integration suite.

The appendix closes with tables of environment variables, CLI commands, and a recap of the circuit architecture and test harness so I donâ€™t have to hunt through the tree when I revisit the project.

\subsubsection{Proof Generation Pipeline}

\begin{enumerate}
    \item \textbf{Circuit Input Mapping}: \texttt{MedicalDataCircuitMapper} converts medical records to field elements:
    \begin{itemize}
        \item Deterministic encoding: \texttt{patient\_id} $\rightarrow$ numeric hash
        \item Field normalization: strings $\rightarrow$ numeric representation
        \item Redaction masking: sensitive fields $\rightarrow$ zero values
        \item Policy encoding: redaction type + reason $\rightarrow$ policy hash
    \end{itemize}
    
    \item \textbf{Witness Generation}: snarkjs computes circuit witness from inputs:
    \begin{verbatim}
snarkjs wtns calculate redaction.wasm input.json witness.wtns
    \end{verbatim}
    
    \item \textbf{Proof Generation}: Groth16 proof created using proving key:
    \begin{verbatim}
snarkjs groth16 prove redaction_final.zkey witness.wtns 
    proof.json public.json
    \end{verbatim}
    
    \item \textbf{Verification}: Off-chain and on-chain verification:
    \begin{itemize}
        \item Off-chain: snarkjs verifies proof against verification key
        \item On-chain: Solidity verifier contract validates proof ($\sim$250k gas)
    \end{itemize}
\end{enumerate}

\subsubsection{Consistency Proof Integration}

Consistency proofs ensure state transitions maintain blockchain integrity:

\begin{itemize}
    \item \textbf{Pre-State Hash}: Hash of contract state before redaction
    \item \textbf{Post-State Hash}: Hash of contract state after redaction
    \item \textbf{Hash Chain Verification}: $H(\text{pre-state}, \text{operation}) = \text{post-state}$
    \item \textbf{Merkle Tree Consistency}: Verify data remains in Merkle tree
    \item \textbf{Circuit Integration}: Consistency proof components added as public inputs
\end{itemize}

The \texttt{prepare\_circuit\_inputs\_with\_consistency()} method in \texttt{circuit\_mapper.py} combines SNARK inputs with consistency proof data, ensuring both cryptographic correctness and state transition validity are verified simultaneously.

\subsection{Phase 2 On-Chain Verification Architecture}

Phase 2 extends Phase 1 with complete on-chain verification, eliminating all simulation code paths.

\subsubsection{Nullifier Registry Contract}

The \texttt{NullifierRegistry.sol} contract prevents replay attacks:

\begin{itemize}
    \item \textbf{Nullifier Tracking}: Maps nullifier $\rightarrow$ timestamp
    \item \textbf{Replay Prevention}: Rejects duplicate nullifiers
    \item \textbf{Batch Operations}: Gas-optimized batch validation ($\sim$40--50\% savings)
    \item \textbf{Audit Trail}: Records submitter address and timestamp for each nullifier
    \item \textbf{Emergency Controls}: Pause/unpause functionality for system maintenance
\end{itemize}

\textbf{Key Functions:}
\begin{verbatim}
function isNullifierValid(bytes32 nullifier) returns (bool)
function recordNullifier(bytes32 nullifier) returns (bool)
function recordNullifierBatch(bytes32[] nullifiers) 
    returns (uint256 successCount)
\end{verbatim}

\subsubsection{Enhanced Medical Data Manager}

The \texttt{MedicalDataManager.sol} contract orchestrates full proof verification:

\begin{enumerate}
    \item \textbf{Nullifier Validation}: Check nullifier not previously used
    \item \textbf{SNARK Verification}: Call Groth16 verifier contract ($\sim$250k gas)
    \item \textbf{Nullifier Recording}: Mark nullifier as used to prevent replay
    \item \textbf{Consistency Storage}: Store consistency proof hash on-chain
    \item \textbf{State Hashes}: Record pre/post-state hashes for audit trail
    \item \textbf{Event Emission}: Emit comprehensive events for monitoring
\end{enumerate}

\textbf{Verification Flow:}
\begin{verbatim}
function requestDataRedactionWithFullProofs(
    string calldata patientId,
    string calldata redactionType,
    string calldata reason,
    uint[2] calldata pA,      // Groth16 proof A
    uint[2][2] calldata pB,   // Groth16 proof B
    uint[2] calldata pC,      // Groth16 proof C
    uint[1] calldata pubSignals,
    bytes32 nullifier,
    bytes32 consistencyProofHash,
    bytes32 preStateHash,
    bytes32 postStateHash
) external returns (uint256 requestId)
\end{verbatim}

\subsubsection{Python Backend Integration}

The \texttt{EVMBackend} class in \texttt{medical/backends.py} implements full proof submission:

\begin{enumerate}
    \item \textbf{Nullifier Generation}: Hash proof data + timestamp
    \item \textbf{State Hash Computation}: SHA-256 of contract state JSON
    \item \textbf{Proof Formatting}: Convert snarkjs output to Solidity calldata
    \item \textbf{Transaction Building}: Construct and sign EVM transaction
    \item \textbf{Submission}: Submit to blockchain with gas estimation
    \item \textbf{Event Monitoring}: Query transaction receipt for emitted events
\end{enumerate}

\subsubsection{Deployment Automation}

The \texttt{contracts/scripts/deploy\_phase2.js} script automates deployment:

\begin{enumerate}
    \item Deploy \texttt{NullifierRegistry} contract
    \item Deploy \texttt{RedactionVerifier\_groth16} verifier contract
    \item Deploy \texttt{MedicalDataManager} with registry and verifier references
    \item Verify configuration correctness
    \item Save deployed addresses to JSON
    \item Generate environment variable template
\end{enumerate}

\subsection{Test Coverage Summary}

\subsubsection{Phase 1 Tests (Zero-Knowledge Proofs)}

\begin{itemize}
    \item \textbf{Circuit Mapper Tests} (351 lines): Field element conversion, policy encoding, Merkle path generation, consistency proof integration
    \item \textbf{SNARK System Tests}: Real proof generation, verification, error handling
    \item \textbf{Consistency System Tests}: Hash chain validation, Merkle tree consistency, state transition verification
    \item \textbf{Integration Tests}: End-to-end proof generation and verification
\end{itemize}

\subsubsection{Phase 2 Tests (On-Chain Verification)}

\begin{itemize}
    \item \textbf{Nullifier Registry Tests} (204 lines): Validity checking, recording, duplicate rejection, batch operations, pause/unpause functionality
    \item \textbf{Phase 2 Integration Tests} (275 lines): Full workflow (SNARK + consistency + nullifier), contract deployment, replay attack prevention, event emissions, error handling
    \item \textbf{Contract Tests}: Solidity unit tests for MedicalDataManager and NullifierRegistry
\end{itemize}

\textbf{Total Coverage:} 40+ unit tests, 15+ integration tests, all passing with real cryptographic implementations.

\subsection{Circuit Development and SNARK Pipeline}

\subsubsection{Prerequisites}

\begin{itemize}
    \item \textbf{circom v2.x}: Circuit compiler (\url{https://docs.circom.io/getting-started/installation/})
    \item \textbf{snarkjs}: Available in \texttt{contracts/node\_modules/.bin/snarkjs} or globally
    \item \textbf{Powers of Tau}: For circuit size ($\sim$6802 constraints), use power $\geq$ 14 (e.g., \texttt{tools/pot14\_final.ptau})
\end{itemize}

\subsubsection{Circuit Files}

\begin{itemize}
    \item \texttt{redaction.circom}: Main circuit implementing:
    \begin{itemize}
        \item $H(\text{original})$ and $H(\text{redacted})$ using MiMC-like permutation
        \item Policy hash matching via MiMC hash of policy preimage
        \item Optional Merkle inclusion proof (8-level binary tree, MiMC-based)
        \item Public boolean gate \texttt{policyAllowed} with checksum output
    \end{itemize}
    \item \texttt{scripts/compile.sh}: Compiles circuit to R1CS/WASM/SYM under \texttt{build/}
    \item \texttt{scripts/setup.sh}: Runs Groth16 setup + contribution, exports verification key
    \item \texttt{scripts/prove.sh}: Generates witness, proof, and verifies (accepts optional input JSON path)
    \item \texttt{scripts/export-verifier.sh}: Exports Solidity verifier to \texttt{contracts/src/RedactionVerifier\_groth16.sol}
    \item \texttt{scripts/clean.sh}: Deletes \texttt{build/} folder
    \item \texttt{input/example.json}: Sample inputs for placeholder circuit
\end{itemize}

\subsubsection{Circuit Quickstart}

\begin{enumerate}
    \item \textbf{Compile circuit}:
    \begin{verbatim}
cd circuits && ./scripts/compile.sh
    \end{verbatim}
    
    \item \textbf{Run Groth16 setup} (provide PTAU path, power $\geq$ 14):
    \begin{verbatim}
PTAU=tools/pot14_final.ptau ./scripts/setup.sh
    \end{verbatim}
    
    \item \textbf{Generate proof} (uses \texttt{input/example.json}):
    \begin{verbatim}
./scripts/prove.sh
    \end{verbatim}
    
    \item \textbf{Export Solidity verifier}:
    \begin{verbatim}
./scripts/export-verifier.sh
    \end{verbatim}
    
    \item \textbf{Compile and test contracts}:
    \begin{verbatim}
cd ../contracts && npx hardhat compile && npx hardhat test
    \end{verbatim}
\end{enumerate}

\subsubsection{Implementation Notes}

\begin{itemize}
    \item Generated verifier written to \texttt{contracts/src/RedactionVerifier\_groth16.sol} to preserve existing stub
    \item Hash/Merkle use MiMC-style permutation with zero round constants (demo-friendly: $H(0,\ldots,0)=0$)
    \item Replace with standard constants or Poseidon for production use
    \item Private arrays: \texttt{originalData[]}, \texttt{redactedData[]}, \texttt{policyData[]}, optional \texttt{merklePathElements[]}, \texttt{merklePathIndices[]}, \texttt{enforceMerkle}
    \item Makefile targets: \texttt{circuits-compile}, \texttt{circuits-setup}, \texttt{circuits-prove}, \texttt{circuits-export-verifier}, \texttt{circuits-clean}, \texttt{circuits-all}
\end{itemize}

\subsection{Integration Testing Infrastructure}

The integration test suite validates interactions with real external services and end-to-end workflows.

\subsubsection{Test Categories}

\begin{enumerate}
    \item \textbf{Service Requirements}: Validates service availability and baseline functionality (always runs)
    \item \textbf{Devnet Infrastructure}: Tests Hardhat node and IPFS daemon lifecycle management
    \item \textbf{Contract Deployment}: Tests automated deployment, address parsing, EVM client loading
    \item \textbf{IPFS Integration}: Real IPFS operations, medical data storage/retrieval, encryption, content integrity
    \item \textbf{End-to-End Workflows}: Complete redaction pipeline from storage to proof verification
    \item \textbf{Environment Validation}: Service requirements, environment variables, graceful fallback, health monitoring
\end{enumerate}

\subsubsection{Running Integration Tests}

\textbf{All integration tests:}
\begin{verbatim}
pytest -m integration tests/test_integration.py -v
\end{verbatim}

\textbf{Specific categories:}
\begin{verbatim}
# Service requirements (always run)
pytest tests/test_integration.py::TestServiceRequirements -v

# Devnet infrastructure (requires Hardhat)
pytest -m "integration and requires_evm" tests/ -v

# IPFS integration (requires IPFS daemon)
pytest -m "integration and requires_ipfs" tests/ -v

# Complete E2E workflows (requires all services)
pytest -m "integration and e2e" tests/ -v

# Skip integration tests
pytest -m "not integration"
\end{verbatim}

\subsubsection{Service Prerequisites}

\begin{itemize}
    \item \textbf{Hardhat}: EVM devnet functionality
    \begin{verbatim}
cd contracts && npm install && npx hardhat --version
    \end{verbatim}
    
    \item \textbf{IPFS}: Distributed storage testing
    \begin{verbatim}
ipfs version && ipfs daemon
    \end{verbatim}
    
    \item \textbf{Web3}: EVM interaction
    \begin{verbatim}
pip install web3>=6
    \end{verbatim}
    
    \item \textbf{snarkjs}: SNARK proof generation (optional)
    \begin{verbatim}
npm install -g snarkjs && snarkjs --version
    \end{verbatim}
\end{itemize}

\subsubsection{Integration Test Features}

\begin{itemize}
    \item \textbf{Automatic Service Discovery}: Tests detect available services, skip gracefully when unavailable
    \item \textbf{Isolated Environments}: Each test runs with dedicated ports, automatic cleanup prevents conflicts
    \item \textbf{Comprehensive E2E}: Full workflow testing:
    \begin{enumerate}
        \item Start IPFS daemon and Hardhat node
        \item Deploy smart contracts
        \item Upload original medical data to IPFS
        \item Create redaction request with SNARK proof
        \item Generate redacted version and upload to IPFS
        \item Update on-chain pointer to redacted version
        \item Verify complete workflow integrity
    \end{enumerate}
    \item \textbf{Error Handling}: Graceful degradation, partial service availability, comprehensive error reporting
\end{itemize}

\subsubsection{Pytest Markers}

\begin{itemize}
    \item \texttt{@pytest.mark.integration}: All integration tests
    \item \texttt{@pytest.mark.requires\_evm}: Tests requiring Hardhat/EVM
    \item \texttt{@pytest.mark.requires\_ipfs}: Tests requiring IPFS daemon
    \item \texttt{@pytest.mark.requires\_snark}: Tests requiring SNARK tools
    \item \texttt{@pytest.mark.e2e}: End-to-end workflow tests
    \item \texttt{@pytest.mark.slow}: Long-running tests (30s--5min)
\end{itemize}

\subsubsection{Troubleshooting Integration Tests}

\textbf{Debug mode:}
\begin{verbatim}
# Detailed output
pytest tests/test_integration.py -v -s --tb=long

# Single test with full debugging
pytest tests/test_integration.py::TestEndToEndWorkflow::
    test_complete_e2e_redaction_workflow -v -s
\end{verbatim}

\textbf{Service health check:}
\begin{verbatim}
python -c "from tests.conftest import check_service_requirements; 
    print(check_service_requirements())"
\end{verbatim}

\textbf{Common issues:}
\begin{itemize}
    \item Port conflicts: Tests automatically find free ports
    \item Service not starting: Check prerequisites and logs
    \item Tests skipping: Normal when services unavailable
    \item Timeout errors: Increase test timeout in pytest configuration
\end{itemize}

\subsection{Known Limitations and Blockers}

\subsubsection{Circuit Compilation Gap}

The circuit source (\texttt{circuits/redaction.circom}) defines 16 public signals for nullifiers, consistency hashes, and policy verification. However, the compiled artifacts in \texttt{circuits/build/} were generated before these additions and export only a single signal. This mismatch is visible in \texttt{circuits/build/public.json}.

Attempting to extract nullifiers from \texttt{pubSignals[8]} when only one element exists causes IndexError. The Python backend works around this by synthesizing nullifiers through timestamp hashing, but these cannot be cryptographically verified since timestamps don't appear in proofs. On-chain verification fails because the Solidity verifier expects the signal count from compilation time.

The circuit was never recompiled after the signal additions because circom v2.x isn't installed on the development machine. Section~A.1.3 provides installation and recompilation instructions.

\subsubsection{On-Chain Verification Failure}

The Hardhat test at \texttt{contracts/test/Groth16Integration.test.js:53} documents that on-chain verification currently returns false. This happens because the Solidity verifier was generated from the 1-signal circuit and expects \texttt{uint[1]} arrays, while the code now prepares 16-signal inputs.

Without working verification, I cannot measure actual gas costs---the $\sim$250k estimate for Groth16 verification is based on code structure, not empirical testing. The nullifier registry can track values, but it cannot enforce replay protection on circuit-derived nullifiers since those don't exist in current proofs. Similarly, consistency proof commitments remain stuck in Python objects rather than being committed on-chain.

After recompiling circuits, I'll need to regenerate the Solidity verifier with \texttt{snarkjs zkey export solidityverifier} and update \texttt{MedicalDataManager.sol} to accept the new signature.

\subsubsection{Off-Chain Nullifier Synthesis}

Since the circuit doesn't export nullifiers, the Python backend generates them by hashing the single public signal concatenated with a timestamp (\texttt{medical/my\_snark\_manager.py:185}). This approach breaks the zero-knowledge model: third parties cannot reproduce the nullifier from proof alone, and the system must maintain a centralized mapping from requests to nullifiers.

Once the circuit is recompiled, nullifiers will be extracted directly from \texttt{pubSignals[8:10]} as two 128-bit limbs, restoring cryptographic binding between proofs and replay-prevention tokens.

\subsubsection{Integration Test Skipping}

Phase 2 integration tests (\texttt{tests/test\_evm\_integration.py}, \texttt{tests/test\_full\_redaction\_pipeline.py}) skip execution when Hardhat or IPFS services aren't running. Only the new unit test at \texttt{tests/test\_backend\_switching.py:197} runs by default because it uses mocks.

This means the claimed end-to-end latency ($\sim$10 seconds in Table~\ref{tab:phase2_performance}) and batch gas savings (43\% for 5 nullifiers) are projections from code, not measurements. The test coverage figures ($>$85\% Python, $>$90\% Solidity) count unit tests with mocked components but not the full integration pathways. Table~\ref{tab:simulation_vs_production} marks the system "Production Ready: Yes" despite production paths being untested.

The circuit compilation gap blocks these tests from generating valid proofs. After recompilation and Hardhat configuration, the full suite can run with \texttt{pytest tests/ -v --run-integration}.

\subsubsection{Summary of Current Capabilities}

The implementation demonstrates understanding of Groth16 SNARKs, circom circuit design, and smart contract integration. Off-chain proof generation works through snarkjs (5--10 seconds per proof, validated in unit tests). The circuit mapper prepares all 16 signals correctly, and nullifier tracking infrastructure exists in both Python and Solidity.

What doesn't work: circuit-derived nullifiers (timestamp hashing used instead), on-chain verification (returns false), nullifier extraction from proofs (IndexError), consistency hash commitments (not in public signals), integration tests (skipped), empirical gas measurements (all projected), and end-to-end audit trails (infrastructure only).