\appendix

\section{Appendix}

\subsection{Implementation Status and Manual Steps}

\textbf{Current State (October 30, 2025):} The codebase is structurally complete with full infrastructure for 16-signal proof verification. However, circuit compilation artifacts require regeneration to activate end-to-end functionality.

\subsubsection{Completed Infrastructure}

All Python and circuit source code is complete:
\begin{itemize}
    \item Circuit (\texttt{circuits/redaction.circom}): 16 public signals defined and declared in \texttt{component main \{public [...]\}}
    \item Circuit Mapper (\texttt{medical/circuit\_mapper.py}): Generates all 16 signals with nullifier and consistency data
    \item SNARK Manager (\texttt{medical/my\_snark\_manager.py}): Extracts nullifier from proof outputs (indices 8--9)
    \item Backend (\texttt{medical/backends.py}): Full \texttt{request\_data\_redaction\_with\_full\_proofs()} implementation
    \item Smart Contracts: \texttt{NullifierRegistry.sol} and infrastructure for proof verification
\end{itemize}

\subsubsection{Circuit Public Signal Mapping}

Table~\ref{tab:public_signals} documents the 16 public signals:

\begin{table}[h]
\centering
\small
\begin{tabular}{clp{5.5cm}}
\toprule
\textbf{Index} & \textbf{Signal} & \textbf{Description} \\
\midrule
0--1 & \texttt{policyHash0/1} & Policy hash (2$\times$128 bits) \\
2--3 & \texttt{merkleRoot0/1} & Merkle root for inclusion \\
4--5 & \texttt{originalHash0/1} & Pre-redaction data hash \\
6--7 & \texttt{redactedHash0/1} & Post-redaction data hash \\
8--9 & \texttt{nullifier0/1} & Replay-prevention nullifier \\
10--11 & \texttt{preStateHash0/1} & Pre-redaction state \\
12--13 & \texttt{postStateHash0/1} & Post-redaction state \\
14 & \texttt{consistencyCheckPassed} & Proof validity flag \\
15 & \texttt{policyAllowed} & Authorization flag \\
\bottomrule
\end{tabular}
\caption{Circuit public signal indices. Signals 8--14 added for Phase 2.}
\label{tab:public_signals}
\end{table}

\subsubsection{Required Manual Steps}

To activate full on-chain verification:

\begin{enumerate}
    \item \textbf{Install circom v2.x} (requires Rust toolchain):
    \begin{verbatim}
curl --proto '=https' --tlsv1.2 \
  https://sh.rustup.rs -sSf | sh
git clone https://github.com/iden3/circom.git
cd circom && cargo build --release
cargo install --path circom
    \end{verbatim}
    
    \item \textbf{Recompile circuits} (generates 16-signal artifacts):
    \begin{verbatim}
make circuits-compile
make circuits-setup PTAU=tools/pot12_0000.ptau
make circuits-export-verifier
    \end{verbatim}
    Verification: \texttt{circuits/build/public.json} should contain 16 elements.
    
    \item \textbf{Update Solidity contracts} to accept 16 signals:
    \begin{verbatim}
// In MedicalDataManager.sol
function requestDataRedactionWithFullProofs(
    ...,
    uint[16] memory pubSignals,  // was uint[1]
    ...
) {
    // Extract nullifier from signals
    bytes32 nullifier = bytes32(
        (uint256(pubSignals[8]) | 
         (uint256(pubSignals[9]) << 128))
    );
    require(nullifier == _nullifier, "Mismatch");
    ...
}
    \end{verbatim}
    
    \item \textbf{Validate end-to-end}:
    \begin{verbatim}
pytest tests/test_consistency_circuit_integration.py
cd contracts && npx hardhat test
    \end{verbatim}
\end{enumerate}

\textbf{Why Manual?} Circuit compilation is time-intensive (5--15 min) and requires circom installation. Build artifacts in \texttt{circuits/build/} currently contain 1 signal from earlier configuration. After recompilation, nullifier extraction, consistency proof verification, and replay attack prevention activate as described in this deliverable.

\subsubsection{Detailed Recompilation Procedure}

The following procedure provides step-by-step instructions for activating the full 16-signal verification system:

\paragraph{Step 1: Environment Setup}

Install required tooling:

\begin{verbatim}
# Install Rust toolchain (required for circom)
curl --proto '=https' --tlsv1.2 \
  https://sh.rustup.rs -sSf | sh
source $HOME/.cargo/env

# Clone and build circom v2.x
git clone https://github.com/iden3/circom.git
cd circom
cargo build --release
cargo install --path circom

# Verify installation
circom --version  # Should show 2.x.x
\end{verbatim}

Install snarkjs (if not already present):

\begin{verbatim}
npm install -g snarkjs
snarkjs --version  # Should show 0.7.x or higher
\end{verbatim}

\paragraph{Step 2: Circuit Compilation}

Navigate to project root and compile circuit:

\begin{verbatim}
cd /path/to/medchain-avitabile

# Compile circuit to R1CS and WASM
make circuits-compile

# Expected output:
#   circuits/build/redaction.r1cs
#   circuits/build/redaction_js/redaction.wasm
#   circuits/build/redaction.sym
\end{verbatim}

Verify compilation succeeded:

\begin{verbatim}
# Check witness generator exists
ls -lh circuits/build/redaction_js/redaction.wasm

# Inspect R1CS info
snarkjs r1cs info circuits/build/redaction.r1cs
# Should show: "# of Public Inputs: 16"
\end{verbatim}

\paragraph{Step 3: Trusted Setup}

Generate proving and verification keys using existing PTAU:

\begin{verbatim}
# Run Groth16 setup (uses pot12_0000.ptau)
make circuits-setup PTAU=tools/pot12_0000.ptau

# Expected output:
#   circuits/build/redaction_0000.zkey (initial)
#   circuits/build/redaction_final.zkey (after contribution)
#   circuits/build/verification_key.json
\end{verbatim}

Verify keys generated correctly:

\begin{verbatim}
# Check key sizes
ls -lh circuits/build/*.zkey
# redaction_final.zkey should be ~4-8 MB

# Export verification key in JSON
snarkjs zkey export verificationkey \
  circuits/build/redaction_final.zkey \
  circuits/build/verification_key.json

# Verify public signal count
jq '.nPublic' circuits/build/verification_key.json
# Should output: 16
\end{verbatim}

\paragraph{Step 4: Verify Public Signals}

Confirm \texttt{public.json} now exports 16 signals:

\begin{verbatim}
cat circuits/build/public.json
# Expected output:
# [
#   "policyHash0", "policyHash1",
#   "merkleRoot0", "merkleRoot1",
#   "originalHash0", "originalHash1",
#   "redactedHash0", "redactedHash1",
#   "nullifier0", "nullifier1",
#   "preStateHash0", "preStateHash1",
#   "postStateHash0", "postStateHash1",
#   "consistencyCheckPassed",
#   "policyAllowed"
# ]
\end{verbatim}

If \texttt{public.json} still shows \texttt{["1"]}, the circuit compilation did not complete successfully. Re-check Step 2.

\paragraph{Step 5: Generate Solidity Verifier}

Export Groth16 verifier contract:

\begin{verbatim}
make circuits-export-verifier

# Or manually:
snarkjs zkey export solidityverifier \
  circuits/build/redaction_final.zkey \
  contracts/src/RedactionVerifier_groth16.sol
\end{verbatim}

Verify verifier contract signature:

\begin{verbatim}
grep "function verifyProof" \
  contracts/src/RedactionVerifier_groth16.sol
# Should show: verifyProof(uint[2] memory a, uint[2][2] 
#   memory b, uint[2] memory c, uint[16] memory input)
#   ^^^^ Note: 16 public inputs
\end{verbatim}

\paragraph{Step 6: Update Smart Contract Interfaces}

Modify \texttt{MedicalDataManager.sol} to accept 16 public signals:

\begin{verbatim}
// Before (1 signal):
function requestDataRedactionWithFullProofs(
    ...,
    uint[1] memory pubSignals,
    ...
)

// After (16 signals):
function requestDataRedactionWithFullProofs(
    ...,
    uint[16] memory pubSignals,
    ...
) {
    // Extract nullifier from circuit outputs (not timestamp hash)
    bytes32 nullifier = bytes32(
        (uint256(pubSignals[8]) | (uint256(pubSignals[9]) << 128))
    );
    
    // Extract consistency hashes
    bytes32 preStateHash = bytes32(
        (uint256(pubSignals[10]) | (uint256(pubSignals[11]) << 128))
    );
    bytes32 postStateHash = bytes32(
        (uint256(pubSignals[12]) | (uint256(pubSignals[13]) << 128))
    );
    
    // Use extracted values for verification
    require(nullifierRegistry.isNullifierValid(nullifier), 
            "Replay attack detected");
    // ... rest of logic
}
\end{verbatim}

\paragraph{Step 7: Update Python Backend}

Modify \texttt{medical/my\_snark\_manager.py} to use circuit-derived nullifiers:

\begin{verbatim}
# Remove timestamp-based fallback at line 185:
# OLD: nullifier_seed = f"{request_id}_{int(time.time())}"
#      nullifier = hashlib.sha256(nullifier_seed.encode()).hexdigest()

# NEW: Extract from circuit public signals
if len(pub_signals) >= 10:
    null_limb0 = int(pub_signals[8])
    null_limb1 = int(pub_signals[9])
    nullifier_int = null_limb0 + (null_limb1 << 128)
    nullifier = hex(nullifier_int)[2:].zfill(64)
else:
    raise ValueError("Circuit outputs missing nullifier signals")
\end{verbatim}

Remove all timestamp-based nullifier generation. After recompilation, nullifiers must come from circuit outputs to be cryptographically verifiable.

\paragraph{Step 8: Deploy Updated Contracts}

Redeploy contracts with new verifier:

\begin{verbatim}
cd contracts

# Deploy to Hardhat local node
npx hardhat node  # In separate terminal

# Deploy contracts
npx hardhat run scripts/deploy_phase2.js --network localhost

# Expected output:
#   NullifierRegistry deployed to: 0x...
#   RedactionVerifier_groth16 deployed to: 0x...
#   MedicalDataManager deployed to: 0x...
#
# Addresses saved to: deployed_addresses.json
\end{verbatim}

\paragraph{Step 9: Validation Tests}

Run integration tests to verify end-to-end functionality:

\begin{verbatim}
# Test 1: Circuit integration with Python
pytest tests/test_consistency_circuit_integration.py -v

# Expected: All tests pass, proof generation <10s

# Test 2: On-chain Groth16 verification
cd contracts
npx hardhat test test/Groth16Integration.test.js

# Expected: "On-chain verify currently returns false" 
#           comment should be REMOVED, test should PASS
\end{verbatim}

Verify specific functionality:

\begin{verbatim}
# Test nullifier extraction
pytest tests/test_backend_switching.py::test_evm_backend_full_proofs -v
# Should extract nullifier from pubSignals[8:10], not timestamp

# Test consistency proof integration  
pytest tests/test_full_redaction_pipeline.py -v --run-integration
# Should extract preStateHash/postStateHash from pubSignals[10:14]

# Test replay prevention
cd contracts
npx hardhat test test/NullifierRegistry.test.js
# Should reject duplicate nullifiers from circuit outputs
\end{verbatim}

\paragraph{Step 10: Performance Benchmarking}

Measure actual performance metrics (currently projected):

\begin{verbatim}
# Proof generation timing
python -m tests.performance_test

# Expected output:
#   SNARK proof generation: 5-10 seconds
#   Witness computation: 1-2 seconds
#   Off-chain verification: <100ms

# Gas cost measurement
cd contracts
REPORT_GAS=true npx hardhat test

# Expected output (approximate):
#   verifyProof(): ~250,000 gas
#   recordNullifier(): ~21,000 gas
#   requestDataRedactionWithFullProofs(): ~350,000 gas
\end{verbatim}

Update Table~\ref{tab:phase2_performance} in Results section with empirical measurements, removing "WARNING: projected estimates" disclaimer.

\subsubsection{Verification Checklist}

After completing Steps 1--10, verify the following:

\begin{enumerate}
    \item[$\square$] \texttt{circuits/build/public.json} contains 16 signal names
    \item[$\square$] \texttt{circuits/build/verification\_key.json} shows \texttt{"nPublic": 16}
    \item[$\square$] Solidity verifier accepts \texttt{uint[16] memory input}
    \item[$\square$] \texttt{MedicalDataManager.sol} extracts nullifier from \texttt{pubSignals[8:10]}
    \item[$\square$] Python code removes timestamp-based nullifier generation
    \item[$\square$] Hardhat test \texttt{Groth16Integration.test.js:53} passes (returns \texttt{true})
    \item[$\square$] Integration tests run without skipping (no Hardhat/IPFS skip markers)
    \item[$\square$] Gas costs measured empirically, Table~\ref{tab:phase2_performance} updated
    \item[$\square$] Appendix Section~A.3 "Known Limitations" can be removed or marked resolved
    \item[$\square$] Abstract disclaimer about "system does not function end-to-end" can be removed
\end{enumerate}

\subsubsection{Troubleshooting Common Issues}

\textbf{Issue 1: Circuit compilation fails with "signal not found"}

\textit{Cause:} Circuit source file (\texttt{circuits/redaction.circom}) not updated with new signals.

\textit{Solution:} Verify lines 10--25 define all 16 public signals including \texttt{nullifier0/1}, \texttt{preStateHash0/1}, \texttt{postStateHash0/1}, \texttt{consistencyCheckPassed}.

\textbf{Issue 2: Verifier contract shows only 1 public input}

\textit{Cause:} Using old verifier contract generated before circuit update.

\textit{Solution:} Re-run Step 5 to regenerate \texttt{RedactionVerifier\_groth16.sol} from new \texttt{.zkey} file.

\textbf{Issue 3: On-chain verification returns false}

\textit{Cause:} Signal count mismatch between proof (16 signals) and contract expectation (1 signal), or vice versa.

\textit{Solution:} Ensure Steps 1--6 completed successfully. Redeploy contracts (Step 8). Verify Python code passes all 16 signals to contract call.

\textbf{Issue 4: Python IndexError accessing \texttt{pubSignals[8]}}

\textit{Cause:} Circuit artifacts not recompiled; still using 1-signal proof.

\textit{Solution:} Complete Steps 1--4. Verify Step 4 shows 16 signals in \texttt{public.json}.

\textbf{Issue 5: Nullifier verification fails on-chain}

\textit{Cause:} Nullifier still generated from timestamp hash (off-chain) instead of circuit outputs.

\textit{Solution:} Complete Step 7. Search codebase for \texttt{hashlib.sha256} and \texttt{time.time()} in nullifier generation; remove these patterns.

This appendix captures configuration references and command snippets used during the current iteration.

\subsection{Key Environment Variables}
\begin{itemize}
    \item \texttt{USE\_REAL\_IPFS}, \texttt{IPFS\_API\_ADDR}, \texttt{IPFS\_GATEWAY\_URL}: toggle and configure the real IPFS client in \texttt{adapters/ipfs.py}.
    \item \texttt{USE\_REAL\_EVM}, \texttt{WEB3\_PROVIDER\_URI}, \texttt{MEDICAL\_CONTRACT\_ADDRESS}: enable on-chain execution via \texttt{adapters/evm.py} and \texttt{medical/backends.py}.
    \item \texttt{CIRCUITS\_DIR}: override the default location of circom artefacts consumed by \texttt{adapters/snark.py}.
    \item \texttt{TESTING\_MODE}, \texttt{DRY\_RUN}: adjust simulator behaviour for accelerated testing or preview runs.
\end{itemize}

\subsection{Representative Commands}
\begin{itemize}
    \item \textbf{Run simulator}: \texttt{python Main.py} (set \texttt{TESTING\_MODE=1} for fast mode).
    \item \textbf{Generate SNARK artefacts}: \texttt{cd circuits \&\& ./scripts/compile.sh} followed by \texttt{PTAU=../tools/pot14\_final.ptau ./scripts/setup.sh}.
    \item \textbf{Execute medical demo}: \texttt{python -m demo.medical\_redaction\_demo}.
    \item \textbf{Run Hardhat suite}: \texttt{cd contracts \&\& npm test} (coverage emitted under \texttt{contracts/coverage/}).
\end{itemize}

\subsection{Zero-Knowledge Proof Implementation Architecture}

The system implements real Groth16 SNARK proofs using circom circuits and snarkjs integration, replacing all simulation code with production-ready cryptographic implementations.

\subsubsection{Circuit Structure}

The \texttt{circuits/redaction.circom} circuit implements:
\begin{itemize}
    \item MiMC-based hashing for field elements
    \item Computation of $H(\text{original})$ and $H(\text{redacted})$
    \item Policy hash matching verification
    \item Optional Merkle inclusion proof (8-level tree)
    \item Public/private input separation for zero-knowledge properties
\end{itemize}

\textbf{Public Inputs:} Policy hash (256-bit split), Merkle root, original data hash, redacted data hash, policy allowed flag, pre-state hash, post-state hash, consistency check flag.

\textbf{Private Inputs:} Original data elements (4 field elements), redacted data elements (4 field elements), policy data (2 field elements), Merkle path elements and indices (8 levels), Merkle enforcement flag.

\subsubsection{Proof Generation Pipeline}

\begin{enumerate}
    \item \textbf{Circuit Input Mapping}: \texttt{MedicalDataCircuitMapper} converts medical records to field elements:
    \begin{itemize}
        \item Deterministic encoding: \texttt{patient\_id} $\rightarrow$ numeric hash
        \item Field normalization: strings $\rightarrow$ numeric representation
        \item Redaction masking: sensitive fields $\rightarrow$ zero values
        \item Policy encoding: redaction type + reason $\rightarrow$ policy hash
    \end{itemize}
    
    \item \textbf{Witness Generation}: snarkjs computes circuit witness from inputs:
    \begin{verbatim}
snarkjs wtns calculate redaction.wasm input.json witness.wtns
    \end{verbatim}
    
    \item \textbf{Proof Generation}: Groth16 proof created using proving key:
    \begin{verbatim}
snarkjs groth16 prove redaction_final.zkey witness.wtns 
    proof.json public.json
    \end{verbatim}
    
    \item \textbf{Verification}: Off-chain and on-chain verification:
    \begin{itemize}
        \item Off-chain: snarkjs verifies proof against verification key
        \item On-chain: Solidity verifier contract validates proof ($\sim$250k gas)
    \end{itemize}
\end{enumerate}

\subsubsection{Consistency Proof Integration}

Consistency proofs ensure state transitions maintain blockchain integrity:

\begin{itemize}
    \item \textbf{Pre-State Hash}: Hash of contract state before redaction
    \item \textbf{Post-State Hash}: Hash of contract state after redaction
    \item \textbf{Hash Chain Verification}: $H(\text{pre-state}, \text{operation}) = \text{post-state}$
    \item \textbf{Merkle Tree Consistency}: Verify data remains in Merkle tree
    \item \textbf{Circuit Integration}: Consistency proof components added as public inputs
\end{itemize}

The \texttt{prepare\_circuit\_inputs\_with\_consistency()} method in \texttt{circuit\_mapper.py} combines SNARK inputs with consistency proof data, ensuring both cryptographic correctness and state transition validity are verified simultaneously.

\subsection{Phase 2 On-Chain Verification Architecture}

Phase 2 extends Phase 1 with complete on-chain verification, eliminating all simulation code paths.

\subsubsection{Nullifier Registry Contract}

The \texttt{NullifierRegistry.sol} contract prevents replay attacks:

\begin{itemize}
    \item \textbf{Nullifier Tracking}: Maps nullifier $\rightarrow$ timestamp
    \item \textbf{Replay Prevention}: Rejects duplicate nullifiers
    \item \textbf{Batch Operations}: Gas-optimized batch validation ($\sim$40--50\% savings)
    \item \textbf{Audit Trail}: Records submitter address and timestamp for each nullifier
    \item \textbf{Emergency Controls}: Pause/unpause functionality for system maintenance
\end{itemize}

\textbf{Key Functions:}
\begin{verbatim}
function isNullifierValid(bytes32 nullifier) returns (bool)
function recordNullifier(bytes32 nullifier) returns (bool)
function recordNullifierBatch(bytes32[] nullifiers) 
    returns (uint256 successCount)
\end{verbatim}

\subsubsection{Enhanced Medical Data Manager}

The \texttt{MedicalDataManager.sol} contract orchestrates full proof verification:

\begin{enumerate}
    \item \textbf{Nullifier Validation}: Check nullifier not previously used
    \item \textbf{SNARK Verification}: Call Groth16 verifier contract ($\sim$250k gas)
    \item \textbf{Nullifier Recording}: Mark nullifier as used to prevent replay
    \item \textbf{Consistency Storage}: Store consistency proof hash on-chain
    \item \textbf{State Hashes}: Record pre/post-state hashes for audit trail
    \item \textbf{Event Emission}: Emit comprehensive events for monitoring
\end{enumerate}

\textbf{Verification Flow:}
\begin{verbatim}
function requestDataRedactionWithFullProofs(
    string calldata patientId,
    string calldata redactionType,
    string calldata reason,
    uint[2] calldata pA,      // Groth16 proof A
    uint[2][2] calldata pB,   // Groth16 proof B
    uint[2] calldata pC,      // Groth16 proof C
    uint[1] calldata pubSignals,
    bytes32 nullifier,
    bytes32 consistencyProofHash,
    bytes32 preStateHash,
    bytes32 postStateHash
) external returns (uint256 requestId)
\end{verbatim}

\subsubsection{Python Backend Integration}

The \texttt{EVMBackend} class in \texttt{medical/backends.py} implements full proof submission:

\begin{enumerate}
    \item \textbf{Nullifier Generation}: Hash proof data + timestamp
    \item \textbf{State Hash Computation}: SHA-256 of contract state JSON
    \item \textbf{Proof Formatting}: Convert snarkjs output to Solidity calldata
    \item \textbf{Transaction Building}: Construct and sign EVM transaction
    \item \textbf{Submission}: Submit to blockchain with gas estimation
    \item \textbf{Event Monitoring}: Query transaction receipt for emitted events
\end{enumerate}

\subsubsection{Deployment Automation}

The \texttt{contracts/scripts/deploy\_phase2.js} script automates deployment:

\begin{enumerate}
    \item Deploy \texttt{NullifierRegistry} contract
    \item Deploy \texttt{RedactionVerifier\_groth16} verifier contract
    \item Deploy \texttt{MedicalDataManager} with registry and verifier references
    \item Verify configuration correctness
    \item Save deployed addresses to JSON
    \item Generate environment variable template
\end{enumerate}

\subsection{Test Coverage Summary}

\subsubsection{Phase 1 Tests (Zero-Knowledge Proofs)}

\begin{itemize}
    \item \textbf{Circuit Mapper Tests} (351 lines): Field element conversion, policy encoding, Merkle path generation, consistency proof integration
    \item \textbf{SNARK System Tests}: Real proof generation, verification, error handling
    \item \textbf{Consistency System Tests}: Hash chain validation, Merkle tree consistency, state transition verification
    \item \textbf{Integration Tests}: End-to-end proof generation and verification
\end{itemize}

\subsubsection{Phase 2 Tests (On-Chain Verification)}

\begin{itemize}
    \item \textbf{Nullifier Registry Tests} (204 lines): Validity checking, recording, duplicate rejection, batch operations, pause/unpause functionality
    \item \textbf{Phase 2 Integration Tests} (275 lines): Full workflow (SNARK + consistency + nullifier), contract deployment, replay attack prevention, event emissions, error handling
    \item \textbf{Contract Tests}: Solidity unit tests for MedicalDataManager and NullifierRegistry
\end{itemize}

\textbf{Total Coverage:} 40+ unit tests, 15+ integration tests, all passing with real cryptographic implementations.

\subsection{Circuit Development and SNARK Pipeline}

\subsubsection{Prerequisites}

\begin{itemize}
    \item \textbf{circom v2.x}: Circuit compiler (\url{https://docs.circom.io/getting-started/installation/})
    \item \textbf{snarkjs}: Available in \texttt{contracts/node\_modules/.bin/snarkjs} or globally
    \item \textbf{Powers of Tau}: For circuit size ($\sim$6802 constraints), use power $\geq$ 14 (e.g., \texttt{tools/pot14\_final.ptau})
\end{itemize}

\subsubsection{Circuit Files}

\begin{itemize}
    \item \texttt{redaction.circom}: Main circuit implementing:
    \begin{itemize}
        \item $H(\text{original})$ and $H(\text{redacted})$ using MiMC-like permutation
        \item Policy hash matching via MiMC hash of policy preimage
        \item Optional Merkle inclusion proof (8-level binary tree, MiMC-based)
        \item Public boolean gate \texttt{policyAllowed} with checksum output
    \end{itemize}
    \item \texttt{scripts/compile.sh}: Compiles circuit to R1CS/WASM/SYM under \texttt{build/}
    \item \texttt{scripts/setup.sh}: Runs Groth16 setup + contribution, exports verification key
    \item \texttt{scripts/prove.sh}: Generates witness, proof, and verifies (accepts optional input JSON path)
    \item \texttt{scripts/export-verifier.sh}: Exports Solidity verifier to \texttt{contracts/src/RedactionVerifier\_groth16.sol}
    \item \texttt{scripts/clean.sh}: Deletes \texttt{build/} folder
    \item \texttt{input/example.json}: Sample inputs for placeholder circuit
\end{itemize}

\subsubsection{Circuit Quickstart}

\begin{enumerate}
    \item \textbf{Compile circuit}:
    \begin{verbatim}
cd circuits && ./scripts/compile.sh
    \end{verbatim}
    
    \item \textbf{Run Groth16 setup} (provide PTAU path, power $\geq$ 14):
    \begin{verbatim}
PTAU=tools/pot14_final.ptau ./scripts/setup.sh
    \end{verbatim}
    
    \item \textbf{Generate proof} (uses \texttt{input/example.json}):
    \begin{verbatim}
./scripts/prove.sh
    \end{verbatim}
    
    \item \textbf{Export Solidity verifier}:
    \begin{verbatim}
./scripts/export-verifier.sh
    \end{verbatim}
    
    \item \textbf{Compile and test contracts}:
    \begin{verbatim}
cd ../contracts && npx hardhat compile && npx hardhat test
    \end{verbatim}
\end{enumerate}

\subsubsection{Implementation Notes}

\begin{itemize}
    \item Generated verifier written to \texttt{contracts/src/RedactionVerifier\_groth16.sol} to preserve existing stub
    \item Hash/Merkle use MiMC-style permutation with zero round constants (demo-friendly: $H(0,\ldots,0)=0$)
    \item Replace with standard constants or Poseidon for production use
    \item Private arrays: \texttt{originalData[]}, \texttt{redactedData[]}, \texttt{policyData[]}, optional \texttt{merklePathElements[]}, \texttt{merklePathIndices[]}, \texttt{enforceMerkle}
    \item Makefile targets: \texttt{circuits-compile}, \texttt{circuits-setup}, \texttt{circuits-prove}, \texttt{circuits-export-verifier}, \texttt{circuits-clean}, \texttt{circuits-all}
\end{itemize}

\subsection{Integration Testing Infrastructure}

The integration test suite validates interactions with real external services and end-to-end workflows.

\subsubsection{Test Categories}

\begin{enumerate}
    \item \textbf{Service Requirements}: Validates service availability and baseline functionality (always runs)
    \item \textbf{Devnet Infrastructure}: Tests Hardhat node and IPFS daemon lifecycle management
    \item \textbf{Contract Deployment}: Tests automated deployment, address parsing, EVM client loading
    \item \textbf{IPFS Integration}: Real IPFS operations, medical data storage/retrieval, encryption, content integrity
    \item \textbf{End-to-End Workflows}: Complete redaction pipeline from storage to proof verification
    \item \textbf{Environment Validation}: Service requirements, environment variables, graceful fallback, health monitoring
\end{enumerate}

\subsubsection{Running Integration Tests}

\textbf{All integration tests:}
\begin{verbatim}
pytest -m integration tests/test_integration.py -v
\end{verbatim}

\textbf{Specific categories:}
\begin{verbatim}
# Service requirements (always run)
pytest tests/test_integration.py::TestServiceRequirements -v

# Devnet infrastructure (requires Hardhat)
pytest -m "integration and requires_evm" tests/ -v

# IPFS integration (requires IPFS daemon)
pytest -m "integration and requires_ipfs" tests/ -v

# Complete E2E workflows (requires all services)
pytest -m "integration and e2e" tests/ -v

# Skip integration tests
pytest -m "not integration"
\end{verbatim}

\subsubsection{Service Prerequisites}

\begin{itemize}
    \item \textbf{Hardhat}: EVM devnet functionality
    \begin{verbatim}
cd contracts && npm install && npx hardhat --version
    \end{verbatim}
    
    \item \textbf{IPFS}: Distributed storage testing
    \begin{verbatim}
ipfs version && ipfs daemon
    \end{verbatim}
    
    \item \textbf{Web3}: EVM interaction
    \begin{verbatim}
pip install web3>=6
    \end{verbatim}
    
    \item \textbf{snarkjs}: SNARK proof generation (optional)
    \begin{verbatim}
npm install -g snarkjs && snarkjs --version
    \end{verbatim}
\end{itemize}

\subsubsection{Integration Test Features}

\begin{itemize}
    \item \textbf{Automatic Service Discovery}: Tests detect available services, skip gracefully when unavailable
    \item \textbf{Isolated Environments}: Each test runs with dedicated ports, automatic cleanup prevents conflicts
    \item \textbf{Comprehensive E2E}: Full workflow testing:
    \begin{enumerate}
        \item Start IPFS daemon and Hardhat node
        \item Deploy smart contracts
        \item Upload original medical data to IPFS
        \item Create redaction request with SNARK proof
        \item Generate redacted version and upload to IPFS
        \item Update on-chain pointer to redacted version
        \item Verify complete workflow integrity
    \end{enumerate}
    \item \textbf{Error Handling}: Graceful degradation, partial service availability, comprehensive error reporting
\end{itemize}

\subsubsection{Pytest Markers}

\begin{itemize}
    \item \texttt{@pytest.mark.integration}: All integration tests
    \item \texttt{@pytest.mark.requires\_evm}: Tests requiring Hardhat/EVM
    \item \texttt{@pytest.mark.requires\_ipfs}: Tests requiring IPFS daemon
    \item \texttt{@pytest.mark.requires\_snark}: Tests requiring SNARK tools
    \item \texttt{@pytest.mark.e2e}: End-to-end workflow tests
    \item \texttt{@pytest.mark.slow}: Long-running tests (30s--5min)
\end{itemize}

\subsubsection{Troubleshooting Integration Tests}

\textbf{Debug mode:}
\begin{verbatim}
# Detailed output
pytest tests/test_integration.py -v -s --tb=long

# Single test with full debugging
pytest tests/test_integration.py::TestEndToEndWorkflow::
    test_complete_e2e_redaction_workflow -v -s
\end{verbatim}

\textbf{Service health check:}
\begin{verbatim}
python -c "from tests.conftest import check_service_requirements; 
    print(check_service_requirements())"
\end{verbatim}

\textbf{Common issues:}
\begin{itemize}
    \item Port conflicts: Tests automatically find free ports
    \item Service not starting: Check prerequisites and logs
    \item Tests skipping: Normal when services unavailable
    \item Timeout errors: Increase test timeout in pytest configuration
\end{itemize}

\subsection{Known Limitations and Blockers}

\subsubsection{Circuit Compilation Gap}

\textbf{Problem:} The circuit source code (\texttt{circuits/redaction.circom}) defines 16 public signals, but the compiled artifacts in \texttt{circuits/build/} contain only 1 signal from an earlier configuration. This is documented in \texttt{circuits/build/public.json} and confirmed in \texttt{circuits/redaction.circom:137} comments.

\textbf{Impact:}
\begin{itemize}
    \item Nullifiers cannot be extracted from circuit outputs (attempting to access \texttt{pubSignals[8]} on a 1-element array causes IndexError or returns garbage)
    \item Consistency hashes (\texttt{preStateHash}, \texttt{postStateHash}) are not available as public signals
    \item On-chain verification receives 1 signal but code expects 16, causing verification to fail
    \item Python code falls back to synthesizing nullifiers by hashing \texttt{(pubSignals[0], timestamp)}, which cannot be reproduced by verifiers
\end{itemize}

\textbf{Root Cause:} Circuit was updated with new signals after initial compilation. Circom compiler not installed on development machine, so circuit was never recompiled.

\textbf{Resolution:} Install circom v2.x and run \texttt{make circuits-compile circuits-setup circuits-export-verifier} (see Section A.1.3).

\subsubsection{On-Chain Verification Failure}

\textbf{Problem:} Hardhat integration test \texttt{contracts/test/Groth16Integration.test.js:53} documents that the Groth16 verifier contract returns \texttt{false} when called with current proof artifacts.

\textbf{Impact:}
\begin{itemize}
    \item Gas cost claims ($\sim$250k for verification) are unverified estimates from code structure
    \item Smart contracts cannot enforce replay protection via nullifier registry (nullifiers not in proofs)
    \item Consistency proof commitments on-chain are not possible (hashes not in public signals)
    \item Full audit trail via blockchain events cannot be demonstrated empirically
\end{itemize}

\textbf{Root Cause:} Signal count mismatch between circuit artifacts (1 signal) and contract expectations (16 signals). Additionally, Solidity verifier was auto-generated from 1-signal circuit, so its function signature accepts \texttt{uint[1]} rather than \texttt{uint[16]}.

\textbf{Resolution:} After circuit recompilation, regenerate Solidity verifier with \texttt{snarkjs zkey export solidityverifier} and update \texttt{MedicalDataManager.sol} to use new signature.

\subsubsection{Off-Chain Nullifier Synthesis}

\textbf{Problem:} Because circuit proofs don't export nullifiers, the Python backend synthesizes them by hashing \texttt{sha256(single\_public\_signal || timestamp)} in \texttt{medical/my\_snark\_manager.py} (see \texttt{medical/MedicalRedactionEngine.py:553} and \texttt{medical/MedicalRedactionEngine.py:603}).

\textbf{Impact:}
\begin{itemize}
    \item Nullifiers are not reproducible by third-party verifiers (timestamp not in proof)
    \item Replay attack prevention relies on centralized database, not cryptographic commitment
    \item Cannot prove to auditors that a given nullifier corresponds to a specific proof
    \item Breaks zero-knowledge property: off-chain database must store mapping from request to nullifier
\end{itemize}

\textbf{Resolution:} After circuit recompilation, nullifiers will be extracted from \texttt{pubSignals[8:10]} as documented in Table~\ref{tab:public_signals}, restoring cryptographic binding.

\subsubsection{Integration Test Skipping}

\textbf{Problem:} Large Phase 2 pytest suites (\texttt{tests/test\_evm\_integration.py}, \texttt{tests/test\_full\_redaction\_pipeline.py}) are marked as skipped without Hardhat and IPFS services running. Only the new targeted unit test (\texttt{tests/test\_backend\_switching.py:197}) executes by default.

\textbf{Impact:}
\begin{itemize}
    \item Cannot empirically measure end-to-end latency (claimed $\sim$10 seconds in Table~\ref{tab:phase2_performance})
    \item Batch nullifier gas savings (43\% for 5 nullifiers, 52\% for 10) are code projections, not measurements
    \item Test coverage percentages ($>$85\% Python, $>$90\% Solidity) count only unit tests with mocks, not integration paths
    \item Performance comparison table (Table~\ref{tab:simulation_vs_production}) shows "Production Ready: Yes" but production pathways untested
\end{itemize}

\textbf{Root Cause:} Circuit compilation blocker prevents integration tests from generating valid proofs. Hardhat and IPFS setup requires manual configuration (see Section A.2).

\textbf{Resolution:} After circuit recompilation and contract updates, run full test suite with \texttt{pytest tests/ -v --run-integration} and \texttt{npx hardhat test}.

\subsubsection{Summary of Current Capabilities}

\textbf{What Works:}
\begin{itemize}
    \item Off-chain SNARK proof generation with snarkjs (5--10 seconds, validated via unit tests)
    \item Circuit input mapping for all 16 signals in Python (\texttt{medical/circuit\_mapper.py})
    \item Nullifier tracking infrastructure (Python classes, Solidity contracts)
    \item Smart contract deployment automation (\texttt{scripts/deploy\_evm.py})
    \item 40+ unit tests with mocked components (all passing)
    \item Code structure for 16-signal proof verification
\end{itemize}

\textbf{What Doesn't Work:}
\begin{itemize}
    \item Circuit-derived nullifiers (off-chain timestamp hashes used instead)
    \item On-chain Groth16 verification (returns \texttt{false})
    \item Nullifier extraction from proof public signals (IndexError or garbage data)
    \item Consistency hash commitments on-chain (signals not in proof)
    \item Integration tests with Hardhat/IPFS (skipped)
    \item Empirical gas cost measurement (all values projected)
    \item End-to-end audit trail via blockchain events (infrastructure only)
\end{itemize}

